#
# vim:ts=4:expandtab
# CORE
# Copyright (c)2010-2012 the Boeing Company.
# See the LICENSE file included in this distribution.
#
''' CCNx user-defined service.
'''

import os

from core.service import CoreService, addservice
from core.misc.ipaddr import IPv4Prefix, IPv6Prefix

class CCNService(CoreService):
    ''' This is a CCNx user-defined service. 
    '''
    # a unique name is required, without spaces
    _name = "CCNService"
    # you can create your own group here
    _group = "Utility"
    # list of other services this service depends on
    _depends = ()
    # per-node directories
    #_dirs = ("/tmp/")
    _dirs = ()
    # generated files (without a full path this file goes in the node's dir,
    #  e.g. /tmp/pycore.12345/n1.conf/)
    _configs = ('ccnservice_start.sh', 'ccnservice_stop.sh', '.bashrc')
    # this controls the starting order vs other enabled services
    _startindex = 50
    # list of startup commands, also may be generated during startup
    _startup = ('/bin/bash ccnservice_start.sh',)
    # list of shutdown commands
    _shutdown = ('/bin/bash ccnservice_stop.sh',)

    _ipv4_routing = True
    _ipv6_routing = False

    @classmethod
    def generateconfig(cls, node, filename, services):
        ''' Return a string that will be written to filename, or sent to the
            GUI for user customization.
        '''
        try:
            ccnx_dir = node.session.cfg['ccnx_dir']
        except KeyError:
            ccnx_dir = "/home/clauz/netgroup/ccn/ccnx-git"  #ARGH!

        cfg =  "#!/bin/bash\n"
        cfg += "# auto-generated by CCNService (ccn.py)\n"
        cfg += "# source /etc/profile \n"
        cfg += "# source /home/clauz/.bashrc \n"

        if filename == cls._configs[0]: # start
                return cfg + cls.generateCcnConf(node, services, ccnx_dir, start=True)
        elif filename == cls._configs[1]: # stop
                return cfg + cls.generateCcnConf(node, services, ccnx_dir, start=False)
        elif filename == cls._configs[2]: # env
                return cls.generateCcnEnv(node, services, ccnx_dir)
        else:
                raise ValueError
    
    @classmethod
    def generateCcnEnv(cls, node, services, ccnx_dir):
            cfg = """
export CCNX_DIR=%s
export SHELL=/bin/bash
export HOME=$PWD
export PATH=$CCNX_DIR/bin:$PATH
export CCN_LOCAL_SOCKNAME="/tmp/.ccnd.%s.sock"
export CCND_KEYSTORE_DIRECTORY="/tmp/ccnd.keystore.%s"
export CCND_LOG="/tmp/ccnd.%s.log"
export TERM=vt100
alias ls='ls --color'

""" % (ccnx_dir, node.name, node.name, node.name)
            return cfg

    @classmethod
    def generateCcnConf(cls, node, services, ccnx_dir, start):
            cfg = """

export CCNX_DIR=%s
export CCN_LOCAL_SOCKNAME="/tmp/.ccnd.%s.sock"
export CCND_KEYSTORE_DIRECTORY="/tmp/ccnd.keystore.%s"
export CCND_LOG="/tmp/ccnd.%s.log"

start() {
    mkdir $CCND_KEYSTORE_DIRECTORY
	$CCNX_DIR/bin/ccndstart
}

stop() {
	$CCNX_DIR/bin/ccndstop
}

""" % (ccnx_dir, node.name, node.name, node.name)
            if start:
                    cfg += "start\n"
            else:
                    cfg += "stop\n"
            return cfg



# this line is required to add the above class to the list of available services
addservice(CCNService)

